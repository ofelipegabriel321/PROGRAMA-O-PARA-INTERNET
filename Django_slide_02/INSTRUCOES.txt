PASSO 01:
    A CLASSE models NOS OFERECE O QUE É NECESSÁRIO PARA FAZER OS MODELOS NO DJANGO, COMO OS TIPOS
    QUE SERÃO GERADOS NO ARQUIVO SQL (CharField, IntegerField, BooleanField, DateField, ETC). PODEM
    SER INSERIDOS EM CADA ATRIBUTO OPCOES DE VALIDAÇÃO: "null" (SE 'TRUE', O ATRIBUTO ACEITARÁ VALORES
    NULOS, O PADRÃO É 'FALSE'); "choices" QUANDO VOCÊ QUISER INSERIR ALGO NA TABELA POR MEIO DE UMA
    ABREVIAÇÃO E COM VALORES FIXOS, USE O CHOICES, QUE SUBSTITUI A ABREVIAÇÃO ESCRITA POR VOCÊ PELA
    OUTRA VERSÃO DA TUPLA (EX: FAÇA ANTES DO ATRIBUTO ISSO: 'SHIRT_SIZES = (('S', 'Small'),
    ('M', 'Medium'), ('L', 'Large'),)', ENTÃO FAÇA O ATRIBUTO "shirt_size =
    models.CharField(max_length=1, choices=SHIRT_SIZES)", ONDE É POSSIVEL OBTER O PRIMEIRO VALOR COM
    "perfil.shirt_size" (OBS: TENHA JÁ UM Perfil SELECIONADO NESSA VARIÁVEL perfil) E O SEGUNDO VALOR
    COM "perfil.get_shirt_size_display()"); "primary_key" QUANDO FOR 'TRUE' DEFINE O ATRIBUTO COMO
    CHAVE PRIMÁRIA; "default" VALOR PADRÃO CASO O CAMPO NÃO SEJA PREENCHIDO.
PASSO 02:
    CONSTRUA A TABELA NO TERMINAL COM "python manage.py makemigrations" E A MATERIALIZE COM
    "python manage.py migrate". ESSE PASSO SERÁ REPETIDO VÁRIAS VEZES AO LONGO DOS PRÓXIMOS PASSOS.
    É ADICIONADO NA TABELA GERADA UM ATRIBUTO "id" COMO CHAVE PRIMÁRIA COM AUTOINCREMENTO. A TABELA
    CRIADA TEM O NOME "mysite_person", QUE É A JUNÇÃO DO NOME DA APLICAÇÃO E DA CLASSE MODEL.
PASSO 03:
    ENTRE NO SHELL COM "python manage.py shell". LÁ VOCÊ PODE IMPORTAR TABELAS (EX: "from myapp.models
    import Person") E POVOÁ-LAS (EX: "person = Person(first_name = 'ely', last_name='Miranda')" E DEPOIS
    "person.save()" (OU APENAS COM "Person.objects.create(first_name = 'ely', last_name='Miranda')")).
    TAMBÉM SÃO BASTANTE ÚTEIS ALGUMAS OPERAÇÕES COM TABELAS: "Person.objects.get(CONDICAO)" (RETORNANDO
    APENAS O OBJETO QUE ENTRA NA CONDIÇÃO), "Person.objects.filter(CONDICAO)" (RETORNANDO UMA LISTA DE
    OBJETOS QUE ENTRAM NA CONDIÇÃO), "Person.objects.all()" (RETORNANDO UMA LISTA COM TODOS OS OBJETOS).
PASSO 04:
    RELACIONAMENTO MUITOS PARA UM.
    É QUANDO UM OBJETO DE UMA CLASSE SE RELACIONA COM MUITOS OBJETOS DE OUTRA CLASSE (ESSE OBJETO
    DESSA OUTRA CLASSE SE RELACIONA EXCLUSIVAMENTE COM UM ÚNICO OBJETO DA PRIMEIRA CLASSE).

    NESSE CASO É NECESSÁRIO FAZER UM ATRIBUTO CHAVE ESTRANGEIRA PARA LIGAR OS OBJETOS QUE POSSUEM
    RELAÇÃO. NO CASO A CLASSE/TABELA DO LADO 'N' RECEBE NO ATRIBUTO CHAVE ESTRANGEIRA O NOME DA CLASSE
    DO LADO '1'. O ATRIBUTO CHAVE ESTRANGEIRA É DO TIPO "models.ForeignKey()", RECEBENDO COMO PRIMEIRO
    PARÂMETRO A TABELA COM QUEM SE RELACIONA. OBSERVE O EXEMPLO DE MODELS NO ARQUIVO 'models.py'. LÁ,
    UM OBJETO DA CLASSE/TABELA "Manufacter" (FABRICANTE) SE RELACIONA COM MUITOS OBJETOS DA
    CLASSE/TABELA "Car", POR ISSO DEVEMOS PÔR O ATRIBUTO "manufacter = models.ForeignKey(Manufacter,
    on_delete=models.CASCADE, related_name="cars")" NO "Car", O LADO "N" DO RELACIONAMENTO. COMO FOI DITO,
    O PRIMEIRO PARÂMETRO É A CLASSE/TABELA DO LADO '1', PERCEBA QUE TAMBÉM FORAM POSTOS OS PARÂMETROS
    "on_delete=models.CASCADE" (QUE CUIDA DE DELETAR O PRÓPRIO OBJETO CASO O OBJETO REFERNCIADO POR
    ELA SEJA EXCLUÍDO) E "related_name="cars"", QUE DETERMINA QUE A RELAÇÃO A RELAÇÃO DE "Car" EM
    "Manufacter" É LOCALIZADA A PARTIR DE "manufacter.cars" (SENDO ESSE "manufacter" UM OBJETO JÁ
    DEFINIDO DA CLASSE "Manufacter").

PASSO 05:
    RELACIONAMENTO MUITOS PARA MUITOS.
    É QUANDO UMA É QUANDO UM OBJETO DE UMA CLASSE SE RELACIONA COM MUITOS OBJETOS DE OUTRA CLASSE (E
    VICE-VERSA).

    É NECESSÁRIO COLOCAR EM UM DOS LADOS DA RELAÇÃO UM ATRIBUTO DO TIPO "models.ManyToManyField",
    ESSE LADO DEVE SER A CLASSE/TABELA DO OBJETO QUE SERIA CRIADO NUMA TELA ENVOLVENDO AS DUAS
    ENTIDADES. POR EXEMPLO: CLASSES "Cobertura" E "Pizza". É MAIS COMUM UMA PIZZA SER CRIADA NUMA
    TELA ENVOLVENDO AS DUAS ENTIDADES, ENTÃO SERÁ POSTO EM "Pizza" O ATRIBUTO "models.ManyToManyField".
    OBSERVE QUE NESSE CASO NÃO SE PÕE O "on_delete=models.CASCADE", POIS A EXCLUSÃO DE UMA COBERTURA
    NÃO FAZ COM QUE UMA PIZZA DEIXE DE EXISTIR E VICE-VERSA (ISSO FICA MAIS VISÍVEL NUMA RELAÇÃO PESSOA
    E GRUPO)

PASSO 06:
    RELACIONAMENTO UM PARA UM.
    É QUANDO UM OBJETO DE CLASSE SE RELACIONA APENAS COM UM OBJETO DE OUTRA CLASSE.

    É NECESSÁRIO COLOCAR EM UM DOS LADOS DA RELAÇÃO UM ATRIBUTO DO TIPO "models.OneToOneField".
    UM EXEMPLO É O RELACIONAMENTO ENTRE AS CLASSES "CPF" E "PessoaFisica". O ATRIBUTO DO TIPO
    "models.OneToOneField" FICA EM "PessoaFisica".

PASSO 07:
    RELACIONAMENTO MUITOS PARA MUITOS AVANÇADO.
    É QUANDO HÁ ATRIBUTOS ADICIONAIS NA TABELA/CLASSE INTERMEDIÁRIA QUE FICA ENTRE UMA TABELA/CLASSE
    E OUTRA.


    PASSO 07.1:
        NESSE CASO, HAVERÃO TRÊS CLASSES/TABELAS, DUAS COM O RELACIONAMENTO MUITOS PARA MUITOS E A
        TERCEIRA QUE IRÁ REPRESENTAR A CLASSE/TABELA INTERMEDIÁRIA. O LADO QUE TEM O ATRIBUTO DO TIPO
        "models.ManyToManyField" TERÁ ADICIONADO NESSE ATRIBUTO O PARÂMETRO "through", QUE RECEBERÁ
        COMO VALOR O NOME DA CLASSE/TABELA INTERMEDIÁRIA (E É ÚLTIL EXATAMENTE PARA APONTAR PARA ESSA
        TABELA). QUANDO VOCÊ CRIA A TABELA INTERMEDIÁRIA ELA DEVE CONTER DOIS APENAS ATRIBUTOS DO TIPO
        "models.ForeignKey", SENDO UM PARA CADA LADO DO RELACIONAMENTO. VEJA NO EXEMPLO ONDE "Person"
        SE RELACIONA COM "Group" TENDO COMO TABELA INTERMEDIÁRIA O "Membership". "Group" POSSUI O
        ATRIBUTO "members = models.ManyToManyField(Person, through='Membership')", QUE, POR MEIO DO
        "through" ESTÁ SETANDO A CLASSE/TABELA "Membership". NESSA CLASSE/TABELA INTERMEDIÁRIA,
        EXISTEM OS ATRIBUTOS "group" E "person" NECESSÁRIOS PARA FORMAR A RELAÇÃO MUITOS PARA MUITOS
        ENTRE "Person" E "Group".

    PASSO 07.2
    CASO VOCÊ QUEIRA ADICIONAR OUTRO "models.ForeignKey" NA TABELA INTERMEDIÁRIA SEM COMPROMETER O
    RELACIONAMENTO MUITOS PARA MUITOS ENTRE "Person" E "Group" VOCÊ DEVE PÔR NO ATRIBUTO DO TIPO
    "models.ManyToManyField" DE "Group" O PARÂMETRO "through_fields" QUE SERVE PARA DIZER QUAIS DOS
    ATRIBUTOS "models.ForeignKey" FAZEM PARTE DA RELAÇÃO MUITOS PARA MUITOS. NO CASO, DEVEM SER PASSADOS
    OS VALORES DESSE MODO: "through_fields=('group', 'person')". NO CASO O ATRIBUTO DO TIPO
    "models.ForeignKey" QUE ADICIONAMOS FOI "inviter = models.ForeignKey(Person,
    on_delete=models.CASCADE, related_name="membership_invites")", QUE TEM ESSE
    "related_name="membership_invites" PORQUE, COMO JÁ EXISTE UM ATRIBUTO DO TIPO "models.ForeignKey"
    SETANDO PARA "Person", É NECESSÁRIO UTILIZAR ESSE PARÂMETRO "related_name".







