---QUESTÃO 01---

PASSO 01:
    FOI CRIADO O "blog_app" COM OS MODELS "Blog" E "Entry" E FEITAS AS MIGRAÇÕES E CRIAÇÃO
    DE TABELA.
PASSO 02:
    PARA SE MONTAR OS SCRIPTS, FOI POSTO EM "settings.py" O 'django_extensions' E INSTALADO
    NO VENV COM "pip install django_extensions". ALÉM DA CRIAÇÃO DA PASTA "scripts" ONDE FOI
    CRIADO O ARQUIVO DE SCRIPT "blog_app_script_01.py". ESSE ARQUIVO SERÁ UMA FUNÇÃO "run()"
    COM SEU CÓDIGO DE SCRIPTS DENTRO DESSA FUNÇÃO, QUE SERÁ EXECUTADO COM O COMANDO "python
    manage.py blog_app_script_01". AQUI FORAM FEITOS OS ".objects.create()" DE CADA OBJETO
    DA CLASSE Blog().
        - ".objects.create()": JÁ CRIA O OBJETO O SALVANDO AUTOMATICAMENTE NA TABELA.
    NO SHELL VOCÊ PODE FAZER UM ".objects.get()" PARA OBTER UM DOS OBJETOS EM ESPECÍFICO,
    PASSANDO O "id" DO OBJETO A SER PROCURADO (".objects.get(id=1)", POR EXEMPLO)
        - ".objects.get()": PASSE NELE COMO PARÂMETRO UM ATRIBUTO ÚNICO A SER PROCURADO, E
        ELE IRÁ RETORNAR O ÚNICO OBJETO COM ESSE ATRIBUTO NESSA CONDIÇÃO.
    PARECIDO COM O ".objects.get()", O ".objects.filter()" SERVE PARA QUANDO VOCÊ DESEJA
    OBTER MAIS DE UM OBJETO QUE ENTRE NA CONDIÇÃO DO ATRIBUTO.
        - ".objects.filter()": RETORNA UMA LISTA COM OBJETOS QUE ENTRAM NA CONDIÇÃO PASSADA
            COMO PARÂMETRO.
        - ".remove()": SERVE PARA DESFAZER O VÍNCULO DE UM OBJETO COM OUTRO (NESSE
            CASO, QUANDO APLICARMOS O "remove()"", FAREMOS O ATRIBUTO CHAVE ESTRANGEIRA DO
            LADO "N" FICAR "None", PERDENDO O VÍNCULO COM O LADO "1". OBS: SÓ É POSSÍVEL
            APLICAR ESSE MÉTODO CASO A CHAVE ESTRANGEIRA NO LADO "N" DA RELAÇÃO ESTIVER
            COM "null=True". ANTES DESSE "." JÁ DEVE ESTAR UM ÚNICO OBJETO, DE ONDE É PEGO
            A LOCALIZAÇÃO DA RELAÇÃO DA CLASSE/TABELA DO LADO N COM A CLASSE/TABELA DO
            LADO 1. OU SEJA, PRIMEIRO SE PEGA ESSE OBJETO A PARTIR COM O GET (VEJA NO
            "blog_app_script_04.py" COMO É FEITO O REMOVE). EM "blog_app_script_04.py",
            PRIMEIRO PEGAMOS O OBJETO A PARTIR DE "Blog.objects.get(id=2)", ENTÃO PEGAMOS
            A LOCALIZAÇÃO DA RELAÇÃO DE "Entry" COM "Blog" A PARTIR DE ".entry_set" (VOCÊ
            PODE TROCAR ESSE NOME COM O ATRIBUTO "related_name"), E ENTÃO É APLICADO O
            ".remove(Entry.objects.get(id=2))" QUE DETERMINA O OBJETO A SER DESVINCULADO.
            LEMBRANDO, SÓ FUNCIONA CASO A CHAVE ESTRANGEIRA NO LADO "N" DA RELAÇÃO ESTIVER
            COM "null=True".
        - ".objects.delete()": DELETA O OBJETO QUE ESTÁ CHAMANDO O MÉTODO
        - ".add()": FUNCIONAMENTO SEMELHANTE AO DO ".remove()", PORÉM, LOGICAMENTE, ELE
            FAZ O VÍNCULO AO INVÉS DE DESVINCULAR
        - ".clear()": FUNCIONAMENTO SEMELHANTE AO DO ".remove()", PORÉM NÃO É PRECISO
            SER PASSADO NO PARÊNTESES O OBJETO A SER DELETADO, POIS TODOS OS OBJETOS (DE
            ".entry_set" NO CASO) SERÃO DESVINCULADOS DA RELAÇÃO.
        - "set()": FUNCIONAMENTO SEMELHANTE AO DO ".remove()" (NA QUESTÃO DE USAR O
            ".entry_set" DO OBJETO SELECIONADO TAMBÉM). ELE SUBSTITUI O CONJUNTO DE
            OBJETOS RELACIONADOS POR OUTRO CONJUNTO DE OBJETOS (PASSADO COMO UMA LISTA
            DE OBJETOS DENTRO DO PARÊNTESES).

---QUESTÃO 02---

